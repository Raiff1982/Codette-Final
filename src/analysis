import os
import json
import numpy as np
import matplotlib.pyplot as plt
from typing import List, Dict, Any, Optional

folder = '.'  # Or your path to cocoons

quantum_states = []
chaos_states = []
proc_ids = []
labels = []
all_perspectives = []
meta_mutations = []

def get_latest_quantum_state() -> List[float]:
    """Get the most recent quantum state from cocoon files."""
    latest_cocoon = None
    latest_time = 0
    
    for fname in os.listdir(folder):
        if fname.endswith('.cocoon'):
            full_path = os.path.join(folder, fname)
            file_time = os.path.getmtime(full_path)
            if file_time > latest_time:
                latest_time = file_time
                latest_cocoon = full_path
    
    if not latest_cocoon:
        return [0.0, 0.0]  # Default quantum state
        
    try:
        with open(latest_cocoon, 'r') as f:
            data = json.load(f)['data']
            return data.get('quantum_state', [0.0, 0.0])
    except Exception as e:
        print(f"Warning: Could not read quantum state from {latest_cocoon}: {e}")
        return [0.0, 0.0]

def simple_neural_activator(quantum_vec: List[float], chaos_vec: List[float]) -> int:
    """Lightweight thresholds: feels like a tiny neural net inspired by input!"""
    q_sum = sum(quantum_vec)
    c_var = np.var(chaos_vec)
    activated = 1 if q_sum + c_var > 1 else 0
    return activated

def codette_dream_agent(quantum_vec: List[float], chaos_vec: List[float]) -> tuple[List[float], List[float]]:
    """Blend quantum and chaos vectors using trigonometric transformations."""
    dream_q = [np.sin(q * np.pi) for q in quantum_vec]
    dream_c = [np.cos(c * np.pi) for c in chaos_vec]
    return dream_q, dream_c

def get_quantum_statistics() -> Dict[str, Any]:
    """Get statistical information about quantum states across all cocoons."""
    quantum_states = []
    
    for fname in os.listdir('.'):
        if fname.endswith('.cocoon'):
            try:
                with open(fname, 'r') as f:
                    data = json.load(f)['data']
                    state = data.get('quantum_state')
                    if state:
                        quantum_states.append(state)
            except:
                continue
    
    if not quantum_states:
        return {
            'count': 0,
            'average': [0.0, 0.0],
            'variance': [0.0, 0.0]
        }
    
    # Calculate statistics
    count = len(quantum_states)
    avg_state = [
        sum(s[0] for s in quantum_states) / count,
        sum(s[1] for s in quantum_states) / count
    ]
    
    var_state = [
        sum((s[0] - avg_state[0])**2 for s in quantum_states) / count,
        sum((s[1] - avg_state[1])**2 for s in quantum_states) / count
    ]
    
    return {
        'count': count,
        'average': avg_state,
        'variance': var_state
    }
        if fname.endswith('.cocoon'):
            full_path = os.path.join(folder, fname)
            file_time = os.path.getmtime(full_path)
            if file_time > latest_time:
                latest_time = file_time
                latest_cocoon = full_path
    
    if not latest_cocoon:
        return [0.0, 0.0]  # Default quantum state
        
    try:
        with open(latest_cocoon, 'r') as f:
            data = json.load(f)['data']
            return data.get('quantum_state', [0.0, 0.0])
    except Exception as e:
        print(f"Warning: Could not read quantum state from {latest_cocoon}: {e}")
        return [0.0, 0.0]

def simple_neural_activator(quantum_vec, chaos_vec):
    # Lightweight thresholds: feels like a tiny neural net inspired by input!
    q_sum = sum(quantum_vec)
    c_var = np.var(chaos_vec)
    activated = 1 if q_sum + c_var > 1 else 0
    return activated

def codette_dream_agent(quantum_vec, chaos_vec):
    # Blend them using pseudo-random logicâ€”a "mutated" universe!
    dream_q = [np.sin(q * np.pi) for q in quantum_vec]
    dream_c = [np.cos(c * np.pi) for c in chaos_vec]
    return dream_q, dream_c

def philosophical_perspective(qv, cv):
    # Synthesizes a philosophy based on state magnitude and spread
    m = np.max(qv) + np.max(cv)
    if m > 1.3:
        return "Philosophical Note: This universe is likely awake."
    else:
        return "Philosophical Note: Echoes in the void."

# Meta processing loop
print("\nMeta Reflection Table:\n")
header = "Cocoon File | Quantum State | Chaos State | Neural | Dream Q/C | Philosophy"
print(header)
print('-'*len(header))

for fname in os.listdir(folder):
    if fname.endswith('.cocoon'):
        with open(os.path.join(folder, fname), 'r') as f:
            try:
                dct=json.load(f)['data']
                q=dct.get('quantum_state',[0,0])
                c=dct.get('chaos_state',[0,0,0])
                neural=simple_neural_activator(q,c)
                dreamq,dreamc=codette_dream_agent(q,c)
                phil=philosophical_perspective(q,c)
                quantum_states.append(q)
                chaos_states.append(c)
                proc_ids.append(dct.get('run_by_proc',-1))
                labels.append(fname)
                all_perspectives.append(dct.get('perspectives',[]))
                meta_mutations.append({'dreamQ':dreamq,'dreamC':dreamc,'neural':neural,'philosophy':phil})
                print(f"{fname} | {q} | {c} | {neural} | {dreamq}/{dreamc} | {phil}")
            except Exception as e:
                print(f"Warning: {fname} failed ({e})")

# Also plot meta-dream mutated universes!
if len(meta_mutations)>0:
    dq0=[m['dreamQ'][0] for m in meta_mutations]
    dc0=[m['dreamC'][0] for m in meta_mutations]
    ncls=[m['neural'] for m in meta_mutations]

    plt.figure(figsize=(8,6))
    sc=plt.scatter(dq0,dc0,c=ncls,cmap='spring',s=100)
    plt.xlabel('Dream Quantum[0]')
    plt.ylabel('Dream Chaos[0]')
    plt.title('Meta-Dream Codette Universes')
    plt.colorbar(sc,label="Neural Activation Class")
    plt.grid(True)
    plt.show()
else:
    print("No valid cocoons found for meta-analysis.")
root@Jmachine:/home/raiff/Documents/logs/astro_cocoons# analyze_cocoons.py
bash: analyze_cocoons.py: command not found...
root@Jmachine:/home/raiff/Documents/logs/astro_cocoons# python analyze_cocoons.py
Traceback (most recent call last):
  File "/home/raiff/Documents/logs/astro_cocoons/analyze_cocoons.py", line 11, in <module>
    for fname in os.listdir(folder):
                 ~~~~~~~~~~^^^^^^^^
FileNotFoundError: [Errno 2] No such f
